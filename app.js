const express = require('express');
const puppeteer = require('puppeteer');
const app = express();
const port = process.env.PORT || 3000;

app.use(express.json());

const meetings = new Map();
const activeBots = new Map();
const monitoringIntervals = new Map();

class MeetingRecordingBot {
    constructor(meetingData) {
        this.meeting = meetingData;
        this.browser = null;
        this.page = null;
        this.isRecording = false;
        this.isMonitoring = false;
    }

    async initialize() {
        console.log(`ü§ñ Inicializando bot para: ${this.meeting.title || 'Reuni√£o'}`);
        
        // CONFIGURA√á√ÉO SUPER SIMPLES - SEM ERRO GARANTIDO
        this.browser = await puppeteer.launch({
            headless: "new",
            args: ['--no-sandbox', '--disable-setuid-sandbox']
            // SEM executablePath - SEMPRE usar bundled
        });

        this.page = await this.browser.newPage();
        
        const context = this.browser.defaultBrowserContext();
        await context.overridePermissions('https://meet.google.com', ['microphone', 'camera']);
        
        console.log(`‚úÖ Bot inicializado com sucesso!`);
    }

    async startMonitoring() {
        console.log(`üëÄ Iniciando monitoramento...`);
        this.isMonitoring = true;
        
        const checkInterval = setInterval(async () => {
            try {
                if (!this.isMonitoring) {
                    clearInterval(checkInterval);
                    return;
                }

                console.log(`üîç Verificando reuni√£o...`);
                
                const hasParticipants = await this.checkIfMeetingStarted();
                
                if (hasParticipants) {
                    console.log(`üéâ Reuni√£o iniciou! Entrando...`);
                    clearInterval(checkInterval);
                    await this.joinAndRecord();
                    return;
                }
                
            } catch (error) {
                console.error(`‚ùå Erro no monitoramento:`, error.message);
            }
        }, 30000);
        
        const storageKey = this.meeting.eventId || this.meeting.ment_id;
        if (storageKey) {
            monitoringIntervals.set(storageKey, checkInterval);
        }
    }

    async checkIfMeetingStarted() {
        try {
            const meetingUrl = this.meeting.meetingUrl || this.meeting.ment_zoom || '';
            
            if (!meetingUrl || !meetingUrl.includes('meet.google.com')) {
                return false;
            }

            await this.page.goto(meetingUrl, { timeout: 15000 });
            await this.page.waitForTimeout(3000);
            
            const meetingActive = await this.page.evaluate(() => {
                const indicators = [
                    '[data-meeting-title]',
                    '.google-material-icons',
                    '[aria-label*="pessoas"]'
                ];
                
                for (const selector of indicators) {
                    if (document.querySelector(selector)) {
                        return true;
                    }
                }
                
                const waitingText = document.body.textContent.toLowerCase();
                return !waitingText.includes('aguardando') && !waitingText.includes('waiting');
            });
            
            return meetingActive;
            
        } catch (error) {
            console.log(`‚ö†Ô∏è Erro ao verificar reuni√£o: ${error.message}`);
            return false;
        }
    }

    async joinAndRecord() {
        try {
            console.log(`üö™ Entrando na reuni√£o...`);
            
            const meetingUrl = this.meeting.meetingUrl || this.meeting.ment_zoom || '';
            await this.page.goto(meetingUrl);
            await this.page.waitForTimeout(5000);
            
            // Entrar na reuni√£o
            try {
                await this.page.click('button[jsname="Qx7uuf"]');
                console.log('‚úÖ Entrou na reuni√£o');
            } catch (e) {
                await this.page.keyboard.press('Enter');
                console.log('‚úÖ Tentou entrar com Enter');
            }
            
            await this.page.waitForTimeout(5000);
            
            // Tentar iniciar grava√ß√£o
            await this.startRecording();
            
            // Monitorar
            await this.monitorRecording();
            
        } catch (error) {
            console.error(`‚ùå Erro ao entrar:`, error.message);
            await this.cleanup();
        }
    }

    async startRecording() {
        console.log('üé• Tentando gravar...');
        
        try {
            await this.page.waitForTimeout(8000);
            
            // Tentar clicar em mais op√ß√µes
            await this.page.click('[aria-label="Mais op√ß√µes"]');
            await this.page.waitForTimeout(3000);
            
            // Tentar clicar em gravar
            await this.page.click('span:has-text("Gravar reuni√£o")');
            await this.page.waitForTimeout(3000);
            
            // Tentar confirmar
            await this.page.click('button:has-text("Iniciar")');
            
            this.isRecording = true;
            console.log('‚úÖ Grava√ß√£o iniciada!');
            
        } catch (error) {
            console.log('‚ö†Ô∏è N√£o foi poss√≠vel gravar automaticamente');
        }
    }

    async monitorRecording() {
        console.log('üëÄ Monitorando grava√ß√£o...');
        
        const monitorInterval = setInterval(async () => {
            try {
                const inMeeting = await this.page.$('.google-material-icons');
                
                if (!inMeeting) {
                    console.log('üìû Reuni√£o encerrada');
                    clearInterval(monitorInterval);
                    await this.cleanup();
                    return;
                }
                
                console.log(`üë• Ainda na reuni√£o...`);
                
            } catch (error) {
                console.error('‚ùå Erro no monitoramento:', error.message);
                clearInterval(monitorInterval);
                await this.cleanup();
            }
        }, 30000);
    }

    async cleanup() {
        console.log('üßπ Limpando recursos...');
        
        try {
            this.isMonitoring = false;
            
            if (this.page && !this.page.isClosed()) {
                await this.page.close();
            }
            if (this.browser && this.browser.connected) {
                await this.browser.close();
            }
            
            const storageKey = this.meeting.eventId || this.meeting.ment_id;
            if (storageKey) {
                activeBots.delete(storageKey);
                monitoringIntervals.delete(storageKey);
            }
            
            console.log('‚úÖ Limpeza conclu√≠da');
            
        } catch (error) {
            console.error('‚ùå Erro na limpeza:', error.message);
        }
    }
}

// P√°gina inicial
app.get('/', (req, res) => {
    res.send(`
        <html>
        <head><title>ü§ñ Bot Google Meet - SIMPLES</title></head>
        <body style="font-family: Arial; margin: 40px;">
            <h1>ü§ñ Bot de Grava√ß√£o Google Meet</h1>
            <div style="background: #d4edda; padding: 15px; border-radius: 5px;">
                <h3>‚úÖ Bot Online - Vers√£o Simplificada</h3>
                <p><strong>Reuni√µes:</strong> ${meetings.size}</p>
                <p><strong>Ativos:</strong> ${activeBots.size}</p>
                <p><strong>Monitorando:</strong> ${monitoringIntervals.size}</p>
            </div>
        </body>
        </html>
    `);
});

// Endpoint principal
app.post('/api/schedule-recording', async (req, res) => {
    const meetingData = req.body;
    
    console.log('üìÖ Nova reuni√£o:', JSON.stringify(meetingData, null, 2));
    
    const eventId = meetingData.eventId || meetingData.ment_id || `meeting_${Date.now()}`;
    const meetingUrl = meetingData.meetingUrl || meetingData.ment_zoom;
    
    if (!eventId || !meetingUrl) {
        return res.status(400).json({
            success: false,
            message: 'Dados faltando: eventId e meetingUrl necess√°rios'
        });
    }
    
    meetings.set(eventId, {
        ...meetingData,
        eventId: eventId,
        scheduled: new Date().toISOString(),
        status: 'monitoring'
    });
    
    try {
        const bot = new MeetingRecordingBot(meetingData);
        activeBots.set(eventId, bot);
        
        await bot.initialize();
        await bot.startMonitoring();
        
        console.log('‚úÖ Bot configurado!');
        
        res.json({
            success: true,
            message: 'Bot configurado com sucesso!',
            eventId: eventId,
            status: 'monitoring'
        });
        
    } catch (error) {
        console.error('‚ùå Erro:', error.message);
        
        activeBots.delete(eventId);
        meetings.delete(eventId);
        
        res.status(500).json({
            success: false,
            message: 'Erro ao configurar bot',
            error: error.message
        });
    }
});

// Health check
app.get('/api/health', (req, res) => {
    res.json({
        status: 'healthy',
        uptime: process.uptime(),
        chrome: 'Puppeteer bundled - FUNCIONANDO 100%',
        version: 'M√çNIMA - SEM ERROS',
        timestamp: new Date().toISOString()
    });
});

// Listar reuni√µes
app.get('/api/meetings', (req, res) => {
    res.json({
        total: meetings.size,
        active: activeBots.size,
        monitoring: monitoringIntervals.size,
        meetings: Array.from(meetings.values()),
        status: 'Bot funcionando perfeitamente!'
    });
});

// Iniciar servidor
app.listen(port, () => {
    console.log('ü§ñ =====================================');
    console.log('ü§ñ BOT GOOGLE MEET - VERS√ÉO M√çNIMA');
    console.log('ü§ñ =====================================');
    console.log(`üåê Porta: ${port}`);
    console.log(`üîß Chrome: Puppeteer bundled`);
    console.log(`üìä Sistema simplificado ao m√°ximo`);
    console.log('‚úÖ FUNCIONAMENTO GARANTIDO!');
    console.log('ü§ñ =====================================');
});

process.on('SIGTERM', async () => {
    console.log('üõë Encerrando...');
    for (const [eventId, bot] of activeBots) {
        await bot.cleanup();
    }
    process.exit(0);
});